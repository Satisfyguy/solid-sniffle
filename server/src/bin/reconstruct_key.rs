//! Reconstruct DB encryption key from Shamir shares (3-of-5)
//!
//! This tool implements the key reconstruction phase of TM-002 mitigation.
//! It takes any 3 of the 5 shares generated by `split_key` and reconstructs
//! the original 256-bit encryption key.
//!
//! # Usage
//!
//! ```bash
//! # Interactive mode (recommended)
//! cargo run --bin reconstruct_key
//!
//! # The tool will prompt for 3 shares:
//! # Enter share 1: AQHvR2xhc3Ntb3JwaGlzbV9kYXJrX2RlczE2ODJfMjAyNQ==
//! # Enter share 2: AgL8UmVjb3Zlcnlfc3lzdGVtX3YxLjBfYnVpbHRfMjAyNQ==
//! # Enter share 3: AwNhY3RpeC13ZWJfYXBwX3NlcnZlcl9ydXN0XzIwMjU=
//! ```
//!
//! # Security Notes
//!
//! - Requires exactly 3 shares (threshold from split_key)
//! - Shares must be base64 encoded (as output by split_key)
//! - Reconstructed key is output to stdout in base64 format
//! - Use IMMEDIATELY then securely delete from memory/screen
//!
//! # Example Output
//!
//! ```text
//! Shamir Secret Sharing - Key Reconstruction Tool
//! ===============================================
//!
//! Enter 3 shares (base64 encoded):
//!
//! Share 1: AQHvR2xhc3Ntb3JwaGlzbV9kYXJrX2RlczE2ODJfMjAyNQ==
//! Share 2: AgL8UmVjb3Zlcnlfc3lzdGVtX3YxLjBfYnVpbHRfMjAyNQ==
//! Share 3: AwNhY3RpeC13ZWJfYXBwX3NlcnZlcl9ydXN0XzIwMjU=
//!
//! ✅ Successfully reconstructed 256-bit key
//!
//! Reconstructed Key (base64):
//! YUJjRGVGZ0hpSmtMbU5vUHFSc1R1VndYeVoxMjM0NTY=
//!
//! Reconstructed Key (hex):
//! 6142634465466748694a6b4c6d4e6f5071527354755677587955313233343536
//!
//! ⚠️  SECURITY WARNING:
//! - This key is displayed on screen - clear terminal after use
//! - Copy to DB_ENCRYPTION_KEY environment variable
//! - Do NOT save to .env file (defeats Shamir purpose)
//! - Use secure deployment method (k8s secrets, HashiCorp Vault, etc.)
//! ```

use anyhow::{Context, Result};
use base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};
use server::crypto::shamir::reconstruct_key;
use std::io::{self, Write};

fn main() -> Result<()> {
    println!("\n╔════════════════════════════════════════════════════════════╗");
    println!("║  Shamir Secret Sharing - Key Reconstruction Tool          ║");
    println!("║  Reconstruct DB encryption key from 3 shares              ║");
    println!("╚════════════════════════════════════════════════════════════╝\n");

    println!("Enter 3 shares (base64 encoded):\n");

    // Read 3 shares from user
    let mut shares = Vec::new();
    for i in 1..=3 {
        print!("Share {}: ", i);
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin()
            .read_line(&mut input)
            .context("Failed to read share")?;
        let input = input.trim();

        // Decode share from base64
        let share_bytes = BASE64
            .decode(input)
            .context(format!("Failed to decode share {} as base64", i))?;

        if share_bytes.len() != 33 {
            anyhow::bail!(
                "Share {} has invalid length: expected 33 bytes, got {}",
                i,
                share_bytes.len()
            );
        }

        shares.push(share_bytes);
    }

    println!("\n🔄 Reconstructing key from shares...\n");

    // Reconstruct key
    let key = reconstruct_key(&shares).context("Failed to reconstruct key")?;

    if key.len() != 32 {
        anyhow::bail!(
            "Reconstructed key has invalid length: expected 32 bytes, got {}",
            key.len()
        );
    }

    // Output reconstructed key in multiple formats
    let key_b64 = BASE64.encode(&key);
    let key_hex = hex::encode(&key);

    println!("✅ Successfully reconstructed 256-bit key\n");
    println!("═══════════════════════════════════════════════════════════\n");
    println!("📦 Reconstructed Key (base64):");
    println!("   {}\n", key_b64);
    println!("📦 Reconstructed Key (hex):");
    println!("   {}\n", key_hex);
    println!("═══════════════════════════════════════════════════════════");

    println!("\n⚠️  CRITICAL SECURITY INSTRUCTIONS:\n");
    println!("1. This key is displayed ON SCREEN - clear terminal after use:");
    println!("   $ clear  # or Ctrl+L\n");
    println!("2. Copy to secure environment variable (DO NOT save to .env):");
    println!("   $ export DB_ENCRYPTION_KEY=\"{}\"\n", key_b64);
    println!("3. For production deployment, use secure secret management:");
    println!("   - Kubernetes Secrets");
    println!("   - HashiCorp Vault");
    println!("   - AWS Secrets Manager");
    println!("   - Azure Key Vault\n");
    println!("4. Verify database decryption works BEFORE deleting shares\n");
    println!("5. After verification, return shares to secure storage\n");

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use server::crypto::shamir::split_key;

    #[test]
    fn test_full_split_reconstruct_cycle() -> Result<()> {
        let original_key = b"test_encryption_key_32_bytes!!";

        // Split
        let shares = split_key(original_key, 5, 3)?;

        // Encode to base64 (simulate user workflow)
        let shares_b64: Vec<String> = shares.iter().map(|s| BASE64.encode(s)).collect();

        // Decode from base64
        let shares_decoded: Vec<Vec<u8>> = shares_b64
            .iter()
            .map(|s| BASE64.decode(s).unwrap())
            .collect();

        // Reconstruct with first 3 shares
        let reconstructed = reconstruct_key(&shares_decoded[0..3])?;

        assert_eq!(reconstructed.as_slice(), original_key);
        Ok(())
    }

    #[test]
    fn test_reconstruct_with_different_share_combinations() -> Result<()> {
        let original_key = b"test_encryption_key_32_bytes!!";
        let shares = split_key(original_key, 5, 3)?;

        // Test all possible 3-of-5 combinations
        let combinations = [
            vec![0, 1, 2],
            vec![0, 1, 3],
            vec![0, 1, 4],
            vec![0, 2, 3],
            vec![0, 2, 4],
            vec![0, 3, 4],
            vec![1, 2, 3],
            vec![1, 2, 4],
            vec![1, 3, 4],
            vec![2, 3, 4],
        ];

        for combo in combinations {
            let selected_shares: Vec<Vec<u8>> =
                combo.iter().map(|&i| shares[i].clone()).collect();

            let reconstructed = reconstruct_key(&selected_shares)?;
            assert_eq!(
                reconstructed.as_slice(),
                original_key,
                "Failed for combination {:?}",
                combo
            );
        }

        Ok(())
    }
}
