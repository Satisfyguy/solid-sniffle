//! Shamir key reconstruction for server startup (TM-002)
//!
//! This module provides interactive Shamir share collection at server boot,
//! eliminating the need to store the DB encryption key in plaintext .env file.
//!
//! # Security Model
//!
//! - Key NEVER stored on disk (only in memory during runtime)
//! - Requires 3 of 5 shares to start server
//! - Shares stored in physically separated locations
//! - Server seizure â†’ attacker needs 3+ share locations
//!
//! # Usage
//!
//! ```rust,no_run
//! use server::crypto::shamir_startup::reconstruct_key_interactive;
//!
//! // At server startup (in main.rs):
//! let db_encryption_key = reconstruct_key_interactive()
//!     .context("Failed to reconstruct DB encryption key from Shamir shares")?;
//!
//! // Use key to initialize database pool
//! let pool = create_pool(&database_url, &db_encryption_key)?;
//! ```

use anyhow::{Context, Result};
use base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};
use std::io::{self, Write};

use super::shamir::reconstruct_key;

/// Interactively collect 3 Shamir shares and reconstruct DB encryption key
///
/// # Returns
///
/// The reconstructed 256-bit (32-byte) encryption key as hex string
///
/// # Errors
///
/// Returns error if:
/// - User input is invalid (not base64, wrong length)
/// - Fewer than 3 shares provided
/// - Share reconstruction fails
/// - Reconstructed key is not 32 bytes
///
/// # Example
///
/// ```rust,no_run
/// let db_key = reconstruct_key_interactive()?;
/// println!("Key reconstructed successfully!");
/// // Use db_key with SQLCipher
/// ```
pub fn reconstruct_key_interactive() -> Result<String> {
    println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘  ðŸ” Shamir Secret Sharing - Server Startup (TM-002)       â•‘");
    println!("â•‘  Database encryption key reconstruction required          â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    println!("âš ï¸  SECURITY REQUIREMENT:");
    println!("   - This server uses Shamir 3-of-5 secret sharing");
    println!("   - DB encryption key is NOT stored on disk");
    println!("   - You must provide 3 of 5 shares to start the server\n");

    println!("Enter 3 shares (base64 encoded):\n");

    // Read 3 shares from stdin
    let mut shares = Vec::new();
    for i in 1..=3 {
        print!("  Share {}/3: ", i);
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin()
            .read_line(&mut input)
            .context(format!("Failed to read share {}", i))?;
        let input = input.trim();

        // Decode share from base64
        let share_bytes = BASE64
            .decode(input)
            .context(format!("Failed to decode share {} as base64. Expected format: AQHvR2xhc3Ntb3JwaGlzbQ==", i))?;

        if share_bytes.len() != 33 {
            anyhow::bail!(
                "Share {} has invalid length: expected 33 bytes, got {}. \
                 Shares must be generated by 'cargo run --bin split_key'",
                i,
                share_bytes.len()
            );
        }

        shares.push(share_bytes);
    }

    println!("\nðŸ”„ Reconstructing 256-bit DB encryption key...");

    // Reconstruct key from shares
    let key_bytes = reconstruct_key(&shares)
        .context("Failed to reconstruct key. Possible causes:\n  \
                 - Shares are from different key splits\n  \
                 - Shares are corrupted\n  \
                 - Wrong shares provided")?;

    if key_bytes.len() != 32 {
        anyhow::bail!(
            "Reconstructed key has invalid length: expected 32 bytes, got {}",
            key_bytes.len()
        );
    }

    // Convert to hex string for SQLCipher
    let key_hex = hex::encode(&key_bytes);

    println!("âœ… Key reconstructed successfully ({} bytes)", key_bytes.len());
    println!("ðŸš€ Starting server with reconstructed encryption key...\n");

    Ok(key_hex)
}

/// Check if Shamir mode is enabled (TM-002 mitigation active)
///
/// # Returns
///
/// `true` if DB_ENCRYPTION_KEY is NOT set in environment (forces Shamir),
/// `false` if DB_ENCRYPTION_KEY is set (.env fallback for development)
///
/// # Usage
///
/// ```rust,no_run
/// if is_shamir_mode_enabled() {
///     let key = reconstruct_key_interactive()?;
/// } else {
///     let key = env::var("DB_ENCRYPTION_KEY")?;
/// }
/// ```
pub fn is_shamir_mode_enabled() -> bool {
    std::env::var("DB_ENCRYPTION_KEY").is_err()
}

/// Get DB encryption key with Shamir fallback
///
/// # Behavior
///
/// 1. If `DB_ENCRYPTION_KEY` env var is set â†’ use it (development mode)
/// 2. If `DB_ENCRYPTION_KEY` NOT set â†’ trigger Shamir reconstruction (production mode)
///
/// # Returns
///
/// DB encryption key as hex string (64 characters)
///
/// # Errors
///
/// Returns error if:
/// - Shamir reconstruction fails (invalid shares, wrong count, etc.)
/// - DB_ENCRYPTION_KEY is set but has wrong format
///
/// # Example
///
/// ```rust,no_run
/// // In main.rs:
/// let db_encryption_key = get_db_encryption_key()
///     .context("Failed to get DB encryption key")?;
///
/// let pool = create_pool(&database_url, &db_encryption_key)?;
/// ```
pub fn get_db_encryption_key() -> Result<String> {
    match std::env::var("DB_ENCRYPTION_KEY") {
        Ok(key) => {
            // Development mode: key from .env
            tracing::warn!(
                "âš ï¸  DB_ENCRYPTION_KEY loaded from environment variable\n  \
                 This is NOT secure for production (TM-002 vulnerability)\n  \
                 Unset DB_ENCRYPTION_KEY to enable Shamir 3-of-5 protection"
            );

            // Validate key format (should be 64 hex chars)
            if key.len() != 64 {
                anyhow::bail!(
                    "DB_ENCRYPTION_KEY has invalid length: expected 64 hex characters, got {}",
                    key.len()
                );
            }

            // Validate hex format
            hex::decode(&key).context("DB_ENCRYPTION_KEY must be valid hex (64 characters)")?;

            Ok(key)
        }
        Err(_) => {
            // Production mode: Shamir reconstruction
            tracing::info!("ðŸ”’ Shamir mode enabled (TM-002 protection active)");
            reconstruct_key_interactive()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::shamir::split_key;

    #[test]
    fn test_shamir_mode_detection() {
        // This test depends on environment state, so we just verify the function works
        let _ = is_shamir_mode_enabled();
    }

    #[test]
    fn test_key_reconstruction_programmatic() -> Result<()> {
        // Generate test key and shares
        let original_key = b"test_encryption_key_32_bytes!!";
        let shares = split_key(original_key, 5, 3)?;

        // Encode shares to base64 (simulate user input)
        let share_b64: Vec<String> = shares.iter().map(|s| BASE64.encode(s)).collect();

        // Manually reconstruct (without interactive prompt)
        let share_bytes: Vec<Vec<u8>> = share_b64
            .iter()
            .take(3)
            .map(|s| BASE64.decode(s).unwrap())
            .collect();

        let reconstructed = reconstruct_key(&share_bytes)?;
        assert_eq!(reconstructed, original_key);

        // Verify hex conversion
        let key_hex = hex::encode(&reconstructed);
        assert_eq!(key_hex.len(), 64); // 32 bytes = 64 hex chars

        Ok(())
    }
}
