{
    "mcpVersion": "1.0.0",
    "requestInfo": {
        "requestId": "req_mcp_transform_002_full",
        "timestamp": "2025-10-19T11:15:20Z",
        "source": "webapp_chat"
    },
    "user": {
        "userId": "user_generic_session_id_123",
        "permissions": [
            "default_user"
        ],
        "language": "fr"
    },
    "session": {
        "sessionId": "session_abc_456",
        "chatHistory": [
            {
                "role": "user",
                "content": "Comment crÃ©e un mcp de A a Z ?"
            },
            {
                "role": "assistant",
                "content": "Pour pouvoir vous expliquer comment crÃ©er un \"MCP\" de A Ã  Z, j'ai besoin d'une petite prÃ©cision..."
            },
            {
                "role": "user",
                "content": "Model context Protocol"
            },
            {
                "role": "assistant",
                "content": "Merci pour la prÃ©cision! \"Model Context Protocol\" (MCP) n'est pas un protocole standard universel..."
            },
            {
                "role": "user",
                "content": "Ensuite il faudrait le dÃ©ployer et le faire communiquer par exemple avec gemini cli via une API ?"
            },
            {
                "role": "assistant",
                "content": "Absolument. C'est l'Ã©tape logique..."
            },
            {
                "role": "user",
                "content": "appeler centre d'Ã©crire un fichier en gisant de dÃ©ployer sur Versailles"
            },
            {
                "role": "assistant",
                "content": "C'est une excellente question, et j'identifie deux points importants dans votre demande..."
            }
        ]
    },
    "domain": {
        "app": "monero_marketplace",
        "projectContextDocument": "# Monero Marketplace Production-Ready Development Skill v2.0\n\n## ðŸŽ¯ Mission Critical Context\n\nYou're developing a **production-grade Monero escrow marketplace** with multisig wallets handling real money. Every line of code you write will be used in production. There is NO separate \"production version\" - what you code today ships to main\n```\n\n---\n\n## ðŸ” Security Hardening Checklist\n\n### Authentication & Authorization\n- [ ] Password hashing with Argon2id (time cost â‰¥ 2, memory cost â‰¥ 19MB)\n- [ ] Session tokens: cryptographically random, 32+ bytes\n- [ ] CSRF tokens on all state-changing operations\n- [ ] Rate limiting: 5 failed logins per IP per hour\n- [ ] Account lockout after 5 failed attempts (24h cooldown)\n- [ ] JWT tokens with short expiration (2h) and refresh mechanism\n- [ ] Role-based access control (RBAC) for all endpoints\n\n### Input Validation\n- [ ] Validate all inputs at API boundary (never trust client)\n- [ ] Sanitize file uploads (magic number verification, size limits)\n- [ ] SQL injection prevention (parameterized queries only)\n- [ ] XSS prevention (escape all user content)\n- [ ] Path traversal prevention (validate file paths)\n- [ ] Email validation with DNS MX record check\n- [ ] Amount validation (min/max limits, decimal precision)\n\n### Cryptography\n- [ ] TLS 1.3 only (disable TLS 1.2 and below)\n- [ ] Perfect Forward Secrecy (PFS) enabled\n- [ ] Strong cipher suites only (AEAD ciphers)\n- [ ] HSTS header with long max-age (31536000)\n- [ ] Certificate pinning for critical connections\n- [ ] Encryption at rest (AES-256-GCM for DB, disk encryption)\n- [ ] Secure key derivation (PBKDF2/Argon2 for passwords)\n\n### Monero Security\n- [ ] Wallet RPC behind firewall (no public exposure)\n- [ ] Authentication on all RPC calls\n- [ ] View-only wallets where possible\n- [ ] Multisig address verification (all parties confirm)\n- [ ] Transaction verification before broadcast\n- [ ] Balance reconciliation (detect discrepancies)\n- [ ] Automatic wallet backups (encrypted, off-site)\n\n### Network Security\n- [ ] Tor hidden service as primary interface\n- [ ] DDoS protection (rate limiting + CloudFlare/similar)\n- [ ] IP allowlisting for admin endpoints\n- [ ] Fail2ban for repeated failures\n- [ ] Network segmentation (DB, RPC, app in separate networks)\n- [ ] Egress filtering (only allow necessary outbound)\n\n### Application Security\n- [ ] No secrets in code/logs/errors\n- [ ] Secure headers (CSP, X-Frame-Options, etc.)\n- [ ] CORS properly configured\n- [ ] Dependency scanning (cargo audit, Dependabot)\n- [ ] Container scanning (Trivy, Clair)\n- [ ] Regular security updates\n- [ ] Principle of least privilege (minimal permissions)\n\n---\n\n## ðŸ“Š Production-Ready Checklist\n\n### Code Quality (Automated)\n- [ ] All tests passing (`cargo test --workspace`)\n- [ ] Zero clippy warnings (`cargo clippy -- -D warnings`)\n- [ ] Code coverage â‰¥85% (`cargo tarpaulin`)\n- [ ] Zero TODO/FIXME in `server/src/` (excluding tests)\n- [ ] All functions documented (missing_docs lint)\n- [ ] No `.unwrap()` in production paths\n- [ ] Integration tests against real testnet\n\n### Security Audit\n- [ ] External security audit completed (professional firm)\n- [ ] All critical/high vulnerabilities fixed\n- [ ] Penetration testing performed\n- [ ] Code review by 2+ senior developers\n- [ ] Bug bounty program active (minimum 4 weeks)\n- [ ] Security documentation complete\n- [ ] Incident response plan tested\n\n### Infrastructure\n- [ ] Production environment provisioned\n- [ ] Monero daemon fully synced (mainnet)\n- [ ] 3 wallet RPC instances operational\n- [ ] Database backups automated (hourly incremental, daily full)\n- [ ] Backup restoration tested successfully\n- [ ] Monitoring and alerting operational\n- [ ] Tor .onion service configured\n- [ ] SSL/TLS certificates valid and auto-renewing\n- [ ] DDoS protection configured\n- [ ] Firewall rules applied and tested\n\n### Operational Readiness\n- [ ] Runbook documented and reviewed\n  - Deployment procedures\n  - Rollback procedures\n  - Backup/restore procedures\n  - Incident response playbook\n  - On-call rotation schedule\n- [ ] 24/7 on-call team defined (minimum 2 people)\n- [ ] Escalation procedures documented\n- [ ] Communication channels established (PagerDuty, Slack, etc.)\n- [ ] Disaster recovery plan tested\n- [ ] Capacity planning completed (expected load + 3x)\n\n### Legal & Compliance\n- [ ] Terms of Service reviewed by lawyer\n- [ ] Privacy Policy compliant with GDPR/local laws\n- [ ] KYC/AML requirements analyzed (consult lawyer)\n- [ ] Data retention policy defined\n- [ ] User data deletion procedures implemented\n- [ ] Jurisdiction considerations documented\n\n### Business Continuity\n- [ ] Key personnel documented (bus factor > 1)\n- [ ] Critical credentials in secure vault (1Password, Bitwarden)\n- [ ] Succession plan for key roles\n- [ ] Financial reserves (3-6 months operating costs)\n- [ ] Insurance coverage evaluated\n\n---\n\n## ðŸš€ Go-Live Decision Matrix\n\n### âœ… GO CRITERIA (All must be met)\n\n| Category | Requirement | Status |\n|----------|-------------|--------|\n| **Security** | External audit: 0 critical, <5 high findings | â˜ |\n| | Penetration testing passed | â˜ |\n| | Bug bounty: 50+ researchers, 0 critical unfixed | â˜ |\n| **Quality** | Code coverage â‰¥85% | â˜ |\n| | Zero TODOs in production code | â˜ |\n| | Integration tests: 100% pass rate | â˜ |\n| **Infrastructure** | All services healthy (7-day uptime) | â˜ |\n| | Monero daemon synced, <1 block behind | â˜ |\n| | Backup/restore tested successfully | â˜ |\n| | Monitoring: 0 false positives | â˜ |\n| **Operations** | On-call team available (2+ people) | â˜ |\n| | Runbook tested with 2+ drills | â˜ |\n| | Incident response: <15 min MTTA | â˜ |\n| **Beta Testing** | 50+ beta users | â˜ |\n| | 100+ successful escrows | â˜ |\n| | 0 fund losses | â˜ |\n| | User satisfaction â‰¥4.0/5.0 | â˜ |\n\n### ðŸ›‘ NO-GO CRITERIA (Any blocks launch)\n\n- âŒ Any unresolved CRITICAL security finding\n- âŒ Failed backup restoration test\n- âŒ Unstable Monero RPC (<99% uptime in last 7 days)\n- âŒ Database corruption detected\n- âŒ Any fund loss in beta (even if reimbursed)\n- âŒ On-call team unavailable\n- âŒ Missing legal review (ToS/Privacy Policy)\n- âŒ Key personnel unavailable for 2+ weeks post-launch\n\n### âš ï¸ CONSIDER DELAYING IF:\n\n- Integration test pass rate <98%\n- Beta testing <30 days\n- Code coverage <80%\n- On-call team has <2 people\n- Documentation incomplete\n- High-severity findings >10\n- User-reported bugs >20 (unfixed)\n\n---\n\n## ðŸ”„ Post-Launch Operations\n\n### Daily Checklist\n```bash\n# Morning checks (automated)\n./scripts/health-check-production.sh\n./scripts/check-blockchain-sync.sh\n./scripts/verify-backups.sh\n\n# Review dashboards\n# - Grafana: Error rates, latency, active escrows\n# - Prometheus: Resource usage\n# - Application logs: Errors/warnings\n```\n\n### Weekly Tasks\n- Review security logs for anomalies\n- Check disk space trends\n- Verify backup retention policy\n- Update dependencies (security patches)\n- Review on-call incidents and improve runbook\n- Capacity planning review\n\n### Monthly Tasks\n- Rotate encryption keys (if using file-based)\n- Full disaster recovery drill\n- Review and update incident response plan\n- Security audit of access logs\n- Performance optimization review\n- Cost optimization review\n\n### Quarterly Tasks\n- External penetration testing\n- Dependency major version updates\n- Infrastructure capacity review\n- Review and update documentation\n- On-call team retrospective\n- Business continuity plan review\n\n---\n\n## ðŸŽ“ Development Best Practices\n\n### Error Handling Philosophy\n\n```rust\n// âŒ NEVER: Swallowing errors\nlet result = some_operation();  // Ignoring Result\n\n// âŒ NEVER: Generic error messages\nreturn Err(anyhow!(\"Failed\"));\n\n// âŒ NEVER: Panicking in production paths\nlet value = config.get(\"key\").unwrap();\n\n// âœ… ALWAYS: Context-rich errors\nlet value = config\n    .get(\"key\")\n    .context(\"Missing required configuration key 'key'\")?;\n\n// âœ… ALWAYS: Structured logging with context\ntracing::error!(\n    escrow_id = %escrow_id,\n    user_id = %user_id,\n    error = %e,\n    \"Failed to release escrow funds\"\n);\n\n// âœ… ALWAYS: Actionable error messages\nreturn Err(WalletError::InsufficientFunds {\n    required: amount,\n    available: balance,\n    suggestion: \"Please deposit additional funds or reduce the escrow amount\"\n});\n```\n\n### Testing Strategy\n\n```rust\n// Unit tests: Fast, isolated, test business logic\n#[test]\nfn test_escrow_amount_validation() {\n    let escrow = Escrow::new(50_000_000); // 0.05 XMR\n    assert!(escrow.validate().is_ok());\n    \n    let escrow = Escrow::new(1_000_000_000_000); // 1000 XMR\n    assert!(matches!(\n        escrow.validate(),\n        Err(ValidationError::AmountExceedsMaximum { .. })\n    ));\n}\n\n// Integration tests: Real services, end-to-end flows\n#[tokio::test]\nasync fn test_full_escrow_with_real_monero() {\n    let env = TestEnvironment::with_real_testnet().await;\n    // Test against actual Monero testnet\n}\n\n// Property-based tests: Fuzzing critical paths\n#[quickcheck]\nfn test_multisig_address_deterministic(seed: u64) -> bool {\n    // Verify same inputs always produce same output\n}\n```\n\n### Logging Levels\n\n```rust\n// ERROR: System is in degraded state, requires immediate attention\ntracing::error!(\n    escrow_id = %escrow_id,\n    error = %e,\n    \"Failed to finalize multisig - manual intervention required\"\n);\n\n// WARN: Unexpected but handled, may indicate future problem\ntracing::warn!(\n    user_id = %user_id,\n    attempt_count = failed_attempts,\n    \"Repeated failed login attempts detected\"\n);\n\n// INFO: Normal operational events (state changes)\ntracing::info!(\n    escrow_id = %escrow_id,\n    from_status = ?old_status,\n    to_status = ?new_status,\n    \"Escrow status changed\"\n);\n\n// DEBUG: Detailed info for troubleshooting (dev/staging only)\ntracing::debug!(\n    rpc_url = %url,\n    method = \"get_balance\",\n    duration_ms = duration.as_millis(),\n    \"Monero RPC call completed\"\n);\n```\n\n### Performance Optimization\n\n```rust\n// Connection pooling\nlazy_static! {\n    static ref DB_POOL: PgPool = create_pool();\n}\n\n// Caching (with TTL)\n#[cached(time = 300, result = true)]  // 5 min cache\nasync fn get_xmr_usd_rate() -> Result<f64> {\n    // Expensive API call\n}\n\n// Batch operations\nlet escrows = get_active_escrows().await?;\nlet balances = fetch_balances_batch(&escrows).await?;\n\n// Async where possible\ntokio::spawn(async move {\n    send_notification(user_id, event).await;\n});\n\n// Database indexes on foreign keys\nCREATE INDEX idx_escrows_order_id ON escrows(order_id);\nCREATE INDEX idx_orders_buyer_id ON orders(buyer_id);\nCREATE INDEX idx_orders_status ON orders(status) WHERE status = 'active';\n```\n\n---\n\n## ðŸ§° Troubleshooting Guide\n\n### Common Issues\n\n**Problem**: Monero RPC timeout\n```bash\n# Check RPC is accessible\ncurl -X POST http://localhost:18083/json_rpc \\\n  -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_version\"}' \\\n  -H 'Content-Type: application/json'\n\n# Check wallet RPC logs\ndocker logs wallet-rpc-1\n\n# Restart RPC if needed\ndocker-compose restart wallet-rpc-1\n```\n\n**Problem**: Database connection pool exhausted\n```sql\n-- Check active connections\nSELECT count(*) FROM pg_stat_activity;\n\n-- Kill idle connections\nSELECT pg_terminate_backend(pid) \nFROM pg_stat_activity \nWHERE state = 'idle' \nAND state_change < current_timestamp - interval '10 minutes';\n```\n\n**Problem**: Escrow stuck in \"SetupInProgress\"\n```bash\n# Check wallet states in database\npsql -c \"SELECT id, status, multisig_state FROM escrows WHERE status = 'setup_in_progress';\"\n\n# Manual recovery (last resort)\n./scripts/recover-stuck-escrow.sh <escrow_id>\n```\n\n---\n\n## ðŸ“š Critical References\n\n### Documentation\n- **Monero RPC**: [https://www.getmonero.org/resources/developer-guides/wallet-rpc.html](https://www.getmonero.org/resources/developer-guides/wallet-rpc.html)\n- **Multisig Guide**: [https://github.com/monero-project/monero/blob/master/docs/multisig.md](https://github.com/monero-project/monero/blob/master/docs/multisig.md)\n- **Diesel ORM**: [https://diesel.rs/guides/](https://diesel.rs/guides/)\n- **Actix-web**: [https://actix.rs/docs/](https://actix.rs/docs/)\n\n### Security Resources\n- **OWASP Top 10**: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n- **Rust Security**: [https://anssi-fr.github.io/rust-guide/](https://anssi-fr.github.io/rust-guide/)\n- **Cryptography**: [https://github.com/RustCrypto](https://github.com/RustCrypto)\n\n---\n\n## ðŸŽ¯ Success Metrics\n\nTrack these KPIs post-launch:\n\n| Metric | Target | Alert Threshold |\n|--------|--------|-----------------|\n| Uptime | 99.9% | <99% |\n| API Response Time (P95) | <200ms | >500ms |\n| Monero RPC Latency (P95) | <2s | >5s |\n| Error Rate | <0.1% | >1% |\n| Successful Escrows | >95% | <90% |\n| Time to Multisig Setup | <5min | >15min |\n| User Satisfaction | >4.5/5 | <4.0/5 |\n| Security Incidents | 0 | Any |\n\n---\n\n## ðŸ”„ Continuous Improvement\n\n### Post-Mortem Process\nAfter any incident:\n1. **Document** within 24h (timeline, root cause, impact)\n2. **Identify** action items (technical, process, documentation)\n3. **Assign** owners with deadlines\n4. **Track** completion\n5. **Share** learnings with team\n6. **Update** runbooks/monitoring\n\n### Feedback Loop\n- Weekly: Review user feedback, identify patterns\n- Bi-weekly: Sprint retrospective (what went well, what to improve)\n- Monthly: Technical debt review, prioritize improvements\n- Quarterly: Architecture review, plan refactors\n\n---\n\n## ðŸŽ¬ Final Words\n\n**Remember**: You're building financial infrastructure. Lives and livelihoods depend on this system working correctly. When in doubt:\n\n1. **Fail safe**: Better to reject a transaction than process it incorrectly\n2. **Be transparent**: Log everything, hide nothing (except secrets)\n3. **Trust no one**: Validate all inputs, verify all outputs\n4. **Automate everything**: Humans make mistakes, especially under pressure\n5. **Test in production**: (but carefully, with feature flags and monitoring)\n\n**The goal isn't just working code - it's production-grade, secure, maintainable, observable, and scalable financial infrastructure.**\n\nGood luck! ðŸš€net.\n\n**Zero-tolerance policy**: No placeholders, no TODOs in production paths, no `.unwrap()` without justification, no mocks in integration tests.\n\n---\n\n## ðŸ—ï¸ Core Architecture\n\n### âœ… Production-Ready Components (100%)\n- **wallet**: Multisig implementation, E2E tests, zero placeholders\n- **cli**: Full command interface with error handling\n- **common**: Shared types, error handling, and utilities\n- **server/database**: Diesel models, R2D2 pool, AES-256-GCM encryption\n- **server/services/escrow**: Real orchestration logic with DB integration\n\n### ðŸš§ Components Requiring Transformation\n1. **WalletManager** (`server/src/wallet_manager.rs`): Documented stubs â†’ Real Monero RPC integration\n2. **WebSocketServer** (`server/src/websocket.rs`): Logging mode â†’ actix-web-actors implementation\n3. **Encryption Keys**: Ephemeral keys â†’ Persistent key management with rotation\n4. **Rate Limiting**: Basic implementation â†’ Production-grade distributed rate limiting\n5. **Health Checks**: Missing â†’ Comprehensive health monitoring\n\n---\n\n## ðŸ”’ Production-First Principles\n\n### CRITICAL RULES\n\n1. **One Codebase**: No dev/prod branches. Use environment variables and feature flags exclusively\n2. **Real Services**: Integration tests against Monero testnet/stagenet, never mocks for critical paths\n3. **Fail Fast**: Invalid config = crash at startup with clear error message, no degraded mode\n4. **Observable**: Structured logs + metrics + traces from day 1\n5. **Zero Placeholders**: No TODO/FIXME/unimplemented!() in production code paths\n6. **Immutable Deployments**: Every deployment is versioned and reproducible\n7. **Circuit Breakers**: All external service calls protected with circuit breakers\n8. **Idempotency**: All state-changing operations must be idempotent\n\n### Configuration Strategy\n\n```rust\n// server/src/config.rs\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum Environment {\n    Development,  // Testnet, verbose logs, relaxed limits\n    Staging,      // Stagenet, production-like config\n    Production,   // Mainnet, strict limits, monitoring\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AppConfig {\n    // Environment\n    pub environment: Environment,\n    pub version: String,\n    \n    // Database\n    pub database_url: String,\n    pub database_pool_size: u32,\n    pub database_connection_timeout: Duration,\n    \n    // Monero\n    pub monero_network: MoneroNetwork,\n    pub monero_daemon_url: String,\n    pub monero_wallet_rpc_urls: Vec<String>,\n    pub monero_rpc_timeout: Duration,\n    pub monero_rpc_retry_attempts: u32,\n    \n    // Business Rules\n    pub max_escrow_amount_xmr: u64,\n    pub min_escrow_amount_xmr: u64,\n    pub escrow_timeout_hours: u64,\n    pub dispute_window_hours: u64,\n    \n    // Security\n    pub rate_limit_requests_per_minute: u32,\n    pub rate_limit_burst: u32,\n    pub session_timeout_hours: u64,\n    pub max_failed_login_attempts: u32,\n    pub password_min_length: usize,\n    \n    // Observability\n    pub log_level: String,\n    pub metrics_port: u16,\n    pub tracing_endpoint: Option<String>,\n    \n    // Server\n    pub server_host: String,\n    pub server_port: u16,\n    pub server_workers: usize,\n    pub max_request_size_bytes: usize,\n    \n    // WebSocket\n    pub ws_heartbeat_interval: Duration,\n    pub ws_client_timeout: Duration,\n    pub ws_max_connections_per_ip: usize,\n    \n    // Encryption\n    pub encryption_key_path: String,\n    pub key_rotation_days: u32,\n    \n    // Tor (optional)\n    pub tor_enabled: bool,\n    pub tor_socks_proxy: Option<String>,\n}\n\nimpl AppConfig {\n    pub fn from_env() -> anyhow::Result<Self> {\n        dotenvy::dotenv().ok();\n        envy::from_env().context(\"Failed to load configuration from environment\")\n    }\n    \n    pub fn validate(&self) -> anyhow::Result<()> {\n        ensure!(self.database_pool_size > 0, \"Database pool size must be > 0\");\n        ensure!(self.max_escrow_amount_xmr > self.min_escrow_amount_xmr, \n                \"Max escrow must be greater than min escrow\");\n        ensure!(self.monero_wallet_rpc_urls.len() >= 3, \n                \"At least 3 wallet RPC URLs required for multisig\");\n        \n        if self.environment == Environment::Production {\n            ensure!(self.monero_network == MoneroNetwork::Mainnet,\n                    \"Production must use mainnet\");\n            ensure!(self.log_level != \"debug\",\n                    \"Production cannot use debug logging\");\n            ensure!(self.rate_limit_requests_per_minute <= 100,\n                    \"Production rate limit too permissive\");\n        }\n        \n        Ok(())\n    }\n}\n```\n\n### Feature Flags (Cargo.toml)\n\n```toml\n[features]\ndefault = [\"testnet\"]\ntestnet = []\nstagenet = []\nmainnet = []\nmonitoring = [\"prometheus\", \"opentelemetry\"]\ntor_support = [\"arti-client\"]\n\n# Mutually exclusive network features\n[package.metadata.cargo-all-features]\ndenylist = [\n    \"testnet\",\n    \"stagenet\", \n    \"mainnet\"\n]\n```\n\n---\n\n## ðŸ“‹ Implementation Roadmap\n\n### PHASE 1: Core Production Components (Weeks 1-2)\n\n#### 1.1 WalletManager Production Implementation\n**File**: `server/src/wallet_manager.rs`\n\n**Current State**: Documented stubs with clear interfaces\n**Target State**: Full Monero RPC integration with state machine\n\n**Requirements**:\n```rust\npub struct WalletInstance {\n    pub id: Uuid,\n    pub role: WalletRole,\n    pub rpc_client: MoneroRpcClient,\n    pub address: String,\n    pub multisig_state: MultisigState,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum MultisigState {\n    NotStarted,\n    PreparedInfo(MultisigInfo),\n    InfoExchanged { round: u8, participants: Vec<String> },\n    Ready { address: String },\n}\n\nimpl WalletManager {\n    pub async fn create_wallet_instance(\n        &mut self,\n        role: WalletRole,\n    ) -> Result<WalletInstance> {\n        // 1. Select available RPC from pool\n        // 2. Create wallet with unique name\n        // 3. Initialize state tracking\n        // 4. Store in DB for recovery\n    }\n    \n    pub async fn make_multisig(\n        &mut self,\n        wallet_id: Uuid,\n        participants: Vec<String>,\n    ) -> Result<MultisigInfo> {\n        // 1. Validate participants (exactly 3)\n        // 2. Call wallet RPC make_multisig\n        // 3. Update state to PreparedInfo\n        // 4. Persist state change\n    }\n    \n    pub async fn exchange_multisig_info(\n        &mut self,\n        escrow_id: Uuid,\n        info_from_all: Vec<MultisigInfo>,\n    ) -> Result<()> {\n        // 1. Validate all info received\n        // 2. Call exchange_multisig_keys for each wallet\n        // 3. Handle multiple rounds if needed\n        // 4. Update all wallet states\n        // 5. Generate final multisig address\n    }\n    \n    pub async fn finalize_multisig(\n        &mut self,\n        escrow_id: Uuid,\n    ) -> Result<String> {\n        // 1. Verify all wallets in InfoExchanged state\n        // 2. Call finalize_multisig on each\n        // 3. Extract and validate multisig address (all must match)\n        // 4. Update states to Ready\n        // 5. Return multisig address\n    }\n}\n```\n\n**Error Handling Strategy**:\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum WalletManagerError {\n    #[error(\"Monero RPC error: {0}\")]\n    RpcError(#[from] MoneroRpcError),\n    \n    #[error(\"Invalid multisig state: expected {expected}, got {actual}\")]\n    InvalidState { expected: String, actual: String },\n    \n    #[error(\"Wallet not found: {0}\")]\n    WalletNotFound(Uuid),\n    \n    #[error(\"All RPC endpoints unavailable\")]\n    NoAvailableRpc,\n    \n    #[error(\"Multisig address mismatch: {addresses:?}\")]\n    AddressMismatch { addresses: Vec<String> },\n}\n```\n\n**Integration Tests**:\n```rust\n#[tokio::test]\nasync fn test_full_multisig_setup() {\n    let config = test_config();\n    let mut manager = WalletManager::new(config).await.unwrap();\n    \n    // Create 3 wallets (buyer, vendor, arbiter)\n    let buyer = manager.create_wallet_instance(WalletRole::Buyer).await.unwrap();\n    let vendor = manager.create_wallet_instance(WalletRole::Vendor).await.unwrap();\n    let arbiter = manager.create_wallet_instance(WalletRole::Arbiter).await.unwrap();\n    \n    // Prepare multisig\n    let buyer_info = manager.make_multisig(buyer.id, vec![]).await.unwrap();\n    let vendor_info = manager.make_multisig(vendor.id, vec![]).await.unwrap();\n    let arbiter_info = manager.make_multisig(arbiter.id, vec![]).await.unwrap();\n    \n    // Exchange info\n    let escrow_id = Uuid::new_v4();\n    manager.exchange_multisig_info(\n        escrow_id,\n        vec![buyer_info, vendor_info, arbiter_info]\n    ).await.unwrap();\n    \n    // Finalize\n    let multisig_address = manager.finalize_multisig(escrow_id).await.unwrap();\n    \n    assert!(multisig_address.starts_with(\"4\")); // Testnet address\n    assert_eq!(multisig_address.len(), 95);\n}\n```\n\n**Success Criteria**:\n- âœ… Real 2-of-3 multisig creation works end-to-end on testnet\n- âœ… Zero stubs/placeholders remaining\n- âœ… State machine prevents invalid transitions\n- âœ… All error cases handled with recovery strategies\n- âœ… Integration tests pass with real Monero testnet\n- âœ… RPC failures trigger circuit breaker\n\n---\n\n#### 1.2 WebSocket Implementation with Actor System\n**File**: `server/src/websocket.rs`\n\n**Requirements**:\n```rust\nuse actix::{Actor, Addr, AsyncContext, StreamHandler};\nuse actix_web_actors::ws;\nuse std::time::{Duration, Instant};\n\nconst HEARTBEAT_INTERVAL: Duration = Duration::from_secs(5);\nconst CLIENT_TIMEOUT: Duration = Duration::from_secs(10);\n\npub struct WebSocketSession {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub hb: Instant,\n    pub server: Addr<WebSocketServer>,\n}\n\nimpl Actor for WebSocketSession {\n    type Context = ws::WebsocketContext<Self>;\n    \n    fn started(&mut self, ctx: &mut Self::Context) {\n        self.hb(ctx);\n        self.server.do_send(Connect {\n            id: self.id,\n            user_id: self.user_id,\n            addr: ctx.address(),\n        });\n    }\n    \n    fn stopped(&mut self, _ctx: &mut Self::Context) {\n        self.server.do_send(Disconnect { id: self.id });\n    }\n}\n\nimpl WebSocketSession {\n    fn hb(&self, ctx: &mut ws::WebsocketContext<Self>) {\n        ctx.run_interval(HEARTBEAT_INTERVAL, |act, ctx| {\n            if Instant::now().duration_since(act.hb) > CLIENT_TIMEOUT {\n                tracing::warn!(session_id = %act.id, \"Heartbeat timeout, disconnecting\");\n                ctx.stop();\n                return;\n            }\n            ctx.ping(b\"\");\n        });\n    }\n}\n\nimpl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession {\n    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {\n        match msg {\n            Ok(ws::Message::Ping(msg)) => {\n                self.hb = Instant::now();\n                ctx.pong(&msg);\n            }\n            Ok(ws::Message::Pong(_)) => {\n                self.hb = Instant::now();\n            }\n            Ok(ws::Message::Text(text)) => {\n                // Handle incoming messages (auth, subscribe to events)\n                if let Err(e) = self.handle_text_message(text, ctx) {\n                    tracing::error!(error = %e, \"Failed to handle message\");\n                }\n            }\n            Ok(ws::Message::Close(reason)) => {\n                ctx.close(reason);\n                ctx.stop();\n            }\n            _ => {}\n        }\n    }\n}\n\npub struct WebSocketServer {\n    sessions: HashMap<Uuid, Addr<WebSocketSession>>,\n    user_sessions: HashMap<Uuid, HashSet<Uuid>>,\n    escrow_subscribers: HashMap<Uuid, HashSet<Uuid>>,\n}\n\nimpl Actor for WebSocketServer {\n    type Context = Context<Self>;\n}\n\n#[derive(Message)]\n#[rtype(result = \"()\")]\npub struct BroadcastEscrowEvent {\n    pub escrow_id: Uuid,\n    pub event: EscrowEvent,\n}\n\nimpl Handler<BroadcastEscrowEvent> for WebSocketServer {\n    type Result = ();\n    \n    fn handle(&mut self, msg: BroadcastEscrowEvent, _ctx: &mut Context<Self>) {\n        if let Some(subscribers) = self.escrow_subscribers.get(&msg.escrow_id) {\n            let payload = serde_json::to_string(&msg.event).unwrap();\n            \n            for session_id in subscribers {\n                if let Some(addr) = self.sessions.get(session_id) {\n                    addr.do_send(WsMessage(payload.clone()));\n                }\n            }\n        }\n    }\n}\n```\n\n**Connection Tracking**:\n- Per-IP connection limits (prevent DoS)\n- Per-user session tracking\n- Escrow-specific subscription system\n- Automatic cleanup on disconnect\n\n**Success Criteria**:\n- âœ… Clients connect to `/ws` successfully\n- âœ… Heartbeat/ping-pong prevents zombie connections\n- âœ… Real-time notifications on escrow state changes\n- âœ… Automatic disconnection and cleanup\n- âœ… Rate limiting per IP address\n- âœ… Load testing: 1000+ concurrent connections\n\n---\n\n#### 1.3 Production-Grade Encryption Key Management\n**New File**: `server/src/crypto/key_manager.rs`\n\n**Requirements**:\n```rust\nuse aes_gcm::{Aes256Gcm, Key, Nonce};\nuse argon2::{Argon2, PasswordHasher};\nuse std::fs;\nuse std::os::unix::fs::PermissionsExt;\n\npub struct KeyManager {\n    master_key: [u8; 32],\n    key_version: u32,\n    key_created_at: DateTime<Utc>,\n}\n\nimpl KeyManager {\n    pub fn new(config: &AppConfig) -> Result<Self> {\n        let key_path = Path::new(&config.encryption_key_path);\n        \n        if key_path.exists() {\n            Self::load_existing_key(key_path)\n        } else {\n            Self::generate_and_save_key(key_path)\n        }\n    }\n    \n    fn load_existing_key(path: &Path) -> Result<Self> {\n        // 1. Read key file\n        let key_data = fs::read(path)\n            .context(\"Failed to read encryption key file\")?;\n        \n        // 2. Verify file permissions\n        let metadata = fs::metadata(path)?;\n        let permissions = metadata.permissions();\n        ensure!(\n            permissions.mode() & 0o777 == 0o600,\n            \"Key file must have 600 permissions\"\n        );\n        \n        // 3. Deserialize and validate\n        let key_info: KeyInfo = serde_json::from_slice(&key_data)?;\n        ensure!(key_info.key.len() == 32, \"Invalid key length\");\n        \n        // 4. Check if key rotation needed\n        let age_days = (Utc::now() - key_info.created_at).num_days();\n        if age_days > config.key_rotation_days as i64 {\n            tracing::warn!(\n                age_days,\n                \"Encryption key rotation recommended\"\n            );\n        }\n        \n        Ok(Self {\n            master_key: key_info.key.try_into().unwrap(),\n            key_version: key_info.version,\n            key_created_at: key_info.created_at,\n        })\n    }\n    \n    fn generate_and_save_key(path: &Path) -> Result<Self> {\n        // 1. Generate secure random key\n        let mut key = [0u8; 32];\n        getrandom::getrandom(&mut key)?;\n        \n        // 2. Create key info\n        let key_info = KeyInfo {\n            version: 1,\n            key: key.to_vec(),\n            created_at: Utc::now(),\n            algorithm: \"AES-256-GCM\".to_string(),\n        };\n        \n        // 3. Save with strict permissions\n        let serialized = serde_json::to_vec_pretty(&key_info)?;\n        fs::write(path, serialized)?;\n        \n        let mut permissions = fs::metadata(path)?.permissions();\n        permissions.set_mode(0o600);\n        fs::set_permissions(path, permissions)?;\n        \n        tracing::info!(\"Generated new encryption key\");\n        \n        Ok(Self {\n            master_key: key,\n            key_version: 1,\n            key_created_at: Utc::now(),\n        })\n    }\n    \n    pub fn encrypt(&self, plaintext: &[u8]) -> Result<Vec<u8>> {\n        let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(&self.master_key));\n        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);\n        \n        let ciphertext = cipher\n            .encrypt(&nonce, plaintext)\n            .map_err(|e| anyhow!(\"Encryption failed: {}\", e))?;\n        \n        // Prepend nonce to ciphertext\n        let mut result = nonce.to_vec();\n        result.extend_from_slice(&ciphertext);\n        Ok(result)\n    }\n    \n    pub fn decrypt(&self, encrypted: &[u8]) -> Result<Vec<u8>> {\n        ensure!(encrypted.len() >= 12, \"Invalid encrypted data\");\n        \n        let (nonce_bytes, ciphertext) = encrypted.split_at(12);\n        let nonce = Nonce::from_slice(nonce_bytes);\n        \n        let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(&self.master_key));\n        cipher\n            .decrypt(nonce, ciphertext)\n            .map_err(|e| anyhow!(\"Decryption failed: {}\", e))\n    }\n}\n\n#[derive(Serialize, Deserialize)]\nstruct KeyInfo {\n    version: u32,\n    key: Vec<u8>,\n    created_at: DateTime<Utc>,\n    algorithm: String,\n}\n```\n\n**Production Recommendations**:\n```rust\n// For real production, integrate with KMS\n#[cfg(feature = \"aws_kms\")]\nimpl KeyManager {\n    pub async fn from_aws_kms(kms_key_id: &str) -> Result<Self> {\n        let kms_client = aws_sdk_kms::Client::new(&aws_config::load_from_env().await);\n        // Generate data key from KMS\n        // Cache encrypted key in memory\n        // Rotate according to KMS policy\n    }\n}\n\n#[cfg(feature = \"vault\")]\nimpl KeyManager {\n    pub async fn from_vault(vault_path: &str) -> Result<Self> {\n        let vault_client = vaultrs::client::VaultClient::new(/* ... */)?;\n        // Fetch key from Vault\n        // Set up auto-renewal\n    }\n}\n```\n\n**Success Criteria**:\n- âœ… Key persists across server restarts\n- âœ… Encrypted data remains decryptable after restart\n- âœ… Key file permissions automatically set to 600\n- âœ… Key rotation warning after configured days\n- âœ… Integration tests verify encryption/decryption\n- âœ… KMS integration documented for production\n\n---\n\n### PHASE 2: Multi-Environment Configuration (Week 2)\n\n#### 2.1 Environment-Specific Configuration Files\n\n**Directory Structure**:\n```\nserver/\nâ”œâ”€â”€ .env.development\nâ”œâ”€â”€ .env.staging\nâ”œâ”€â”€ .env.production.example\nâ””â”€â”€ config/\n    â”œâ”€â”€ development.toml\n    â”œâ”€â”€ staging.toml\n    â””â”€â”€ production.toml.example\n```\n\n**Environment Profiles**:\n\n| Parameter | Development | Staging | Production |\n|-----------|-------------|---------|------------|\n| **Network** |\n| Monero Network | Testnet | Stagenet | Mainnet |\n| Daemon URL | Local | Shared testnet | Dedicated |\n| **Limits** |\n| Max Escrow | 10 XMR | 1 XMR | 5 XMR |\n| Min Escrow | 0.01 XMR | 0.1 XMR | 0.1 XMR |\n| Rate Limit | 1000/min | 100/min | 60/min |\n| Burst | 50 | 20 | 10 |\n| **Timeouts** |\n| Session | 24h | 8h | 2h |\n| Escrow | 72h | 48h | 24h |\n| Dispute Window | 168h | 72h | 48h |\n| **Observability** |\n| Log Level | debug | info | warn |\n| Metrics | disabled | enabled | enabled |\n| Tracing | disabled | sampled (10%) | sampled (1%) |\n| **Database** |\n| Pool Size | 5 | 20 | 50 |\n| Connection Timeout | 30s | 10s | 5s |\n| **WebSocket** |\n| Max Conn/IP | 100 | 10 | 5 |\n| Heartbeat | 30s | 10s | 5s |\n\n**Configuration Loader**:\n```rust\nimpl AppConfig {\n    pub fn load() -> Result<Self> {\n        let env = std::env::var(\"APP_ENV\")\n            .unwrap_or_else(|_| \"development\".to_string());\n        \n        let config_file = match env.as_str() {\n            \"development\" => \"config/development.toml\",\n            \"staging\" => \"config/staging.toml\",\n            \"production\" => \"config/production.toml\",\n            _ => bail!(\"Unknown environment: {}\", env),\n        };\n        \n        // 1. Load from TOML file\n        let mut config: AppConfig = toml::from_str(&fs::read_to_string(config_file)?)?;\n        \n        // 2. Override with environment variables\n        config = envy::from_env()?;\n        \n        // 3. Validate configuration\n        config.validate()?;\n        \n        // 4. Log configuration (sanitized)\n        tracing::info!(\n            environment = ?config.environment,\n            version = %config.version,\n            monero_network = ?config.monero_network,\n            \"Configuration loaded successfully\"\n        );\n        \n        Ok(config)\n    }\n}\n```\n\n**Success Criteria**:\n- âœ… Single binary works in all environments\n- âœ… `APP_ENV=production cargo run` uses production config\n- âœ… Cannot start production without all required variables\n- âœ… Configuration errors are clear and actionable\n- âœ… Secrets never logged\n\n---\n\n#### 2.2 Circuit Breakers for External Services\n\n**New File**: `server/src/resilience/circuit_breaker.rs`\n\n```rust\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\npub struct CircuitBreaker {\n    state: Arc<RwLock<BreakerState>>,\n    config: BreakerConfig,\n}\n\n#[derive(Clone)]\nstruct BreakerConfig {\n    failure_threshold: u32,\n    success_threshold: u32,\n    timeout: Duration,\n    half_open_max_requests: u32,\n}\n\nenum BreakerState {\n    Closed { failure_count: u32 },\n    Open { opened_at: Instant },\n    HalfOpen { success_count: u32, request_count: u32 },\n}\n\nimpl CircuitBreaker {\n    pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError>\n    where\n        F: FnOnce() -> Result<T, E>,\n        E: std::error::Error,\n    {\n        let mut state = self.state.write().await;\n        \n        match *state {\n            BreakerState::Open { opened_at } => {\n                if opened_at.elapsed() >= self.config.timeout {\n                    *state = BreakerState::HalfOpen {\n                        success_count: 0,\n                        request_count: 0,\n                    };\n                } else {\n                    return Err(CircuitBreakerError::Open);\n                }\n            }\n            BreakerState::HalfOpen { request_count, .. } => {\n                if request_count >= self.config.half_open_max_requests {\n                    return Err(CircuitBreakerError::TooManyRequests);\n                }\n            }\n            _ => {}\n        }\n        \n        drop(state);\n        \n        match f() {\n            Ok(result) => {\n                self.on_success().await;\n                Ok(result)\n            }\n            Err(e) => {\n                self.on_failure().await;\n                Err(CircuitBreakerError::CallFailed(e.to_string()))\n            }\n        }\n    }\n}\n```\n\n**Integration**:\n```rust\n// Wrap Monero RPC calls\npub struct ResilientMoneroRpc {\n    client: MoneroRpcClient,\n    circuit_breaker: CircuitBreaker,\n}\n\nimpl ResilientMoneroRpc {\n    pub async fn get_balance(&self, wallet: &str) -> Result<u64> {\n        self.circuit_breaker.call(|| {\n            self.client.get_balance(wallet)\n        }).await?\n    }\n}\n```\n\n---\n\n### PHASE 3: Quality & Security (Week 3)\n\n#### 3.1 Enhanced Pre-commit Hooks\n\n**File**: `scripts/pre-commit.sh`\n\n```bash\n#!/bin/bash\nset -e\n\necho \"ðŸ” Running pre-commit checks...\"\n\n# 1. Format check\necho \"ðŸ“ Checking formatting...\"\ncargo fmt -- --check || {\n    echo \"âŒ Code not formatted. Run: cargo fmt\"\n    exit 1\n}\n\n# 2. Clippy with strict lints\necho \"ðŸ”§ Running clippy...\"\ncargo clippy --all-targets --all-features -- \\\n    -D warnings \\\n    -D clippy::unwrap_used \\\n    -D clippy::expect_used \\\n    -D clippy::panic \\\n    -D clippy::todo \\\n    -D clippy::unimplemented || {\n    echo \"âŒ Clippy checks failed\"\n    exit 1\n}\n\n# 3. Check for TODOs in production code\necho \"ðŸš« Checking for TODOs in src/...\"\nif grep -r \"TODO\\|FIXME\\|XXX\" server/src --exclude-dir=tests --exclude=\"*.md\"; then\n    echo \"âŒ Found TODO/FIXME in production code\"\n    exit 1\nfi\n\n# 4. Security audit\necho \"ðŸ”’ Running security audit...\"\ncargo audit || {\n    echo \"âŒ Security vulnerabilities found\"\n    exit 1\n}\n\n# 5. Check for hardcoded secrets\necho \"ðŸ” Scanning for secrets...\"\nif command -v gitleaks &> /dev/null; then\n    gitleaks detect --no-git --verbose || {\n        echo \"âŒ Potential secrets found\"\n        exit 1\n    }\nelse\n    echo \"âš ï¸  gitleaks not installed, skipping secret scan\"\nfi\n\n# 6. Run tests\necho \"ðŸ§ª Running tests...\"\ncargo test --workspace --all-features || {\n    echo \"âŒ Tests failed\"\n    exit 1\n}\n\n# 7. Check documentation\necho \"ðŸ“š Checking documentation...\"\ncargo doc --no-deps --all-features || {\n    echo \"âŒ Documentation build failed\"\n    exit 1\n}\n\n# 8. Verify environment files\necho \"ðŸŒ Validating environment configurations...\"\nfor env_file in .env.development .env.staging; do\n    if [[ ! -f \"$env_file\" ]]; then\n        echo \"âŒ Missing $env_file\"\n        exit 1\n    fi\ndone\n\necho \"âœ… All pre-commit checks passed!\"\n```\n\n**Installation**:\n```bash\nchmod +x scripts/pre-commit.sh\nln -sf ../../scripts/pre-commit.sh .git/hooks/pre-commit\n```\n\n---\n\n#### 3.2 Comprehensive Integration Tests\n\n**New File**: `server/tests/integration/full_escrow_flow.rs`\n\n```rust\n#[tokio::test]\nasync fn test_complete_escrow_lifecycle() {\n    let test_env = TestEnvironment::setup().await;\n    \n    // 1. Register users\n    let buyer = test_env.create_user(\"buyer@example.com\", \"password123\").await?;\n    let vendor = test_env.create_user(\"vendor@example.com\", \"password456\").await?;\n    let arbiter = test_env.create_arbiter(\"arbiter@example.com\", \"password789\").await?;\n    \n    // 2. Vendor creates listing\n    let listing = test_env.create_listing(\n        vendor.id,\n        \"Test Product\",\n        100_000_000, // 0.1 XMR\n    ).await?;\n    \n    // 3. Buyer creates order\n    let order = test_env.create_order(buyer.id, listing.id).await?;\n    assert_eq!(order.status, OrderStatus::Pending);\n    \n    // 4. Initialize escrow (triggers multisig setup)\n    let escrow = test_env.initialize_escrow(order.id, arbiter.id).await?;\n    assert_eq!(escrow.status, EscrowStatus::SetupInProgress);\n    \n    // 5. All participants prepare multisig\n    test_env.complete_multisig_setup(escrow.id).await?;\n    \n    // Verify multisig address generated\n    let escrow = test_env.get_escrow(escrow.id).await?;\n    assert_eq!(escrow.status, EscrowStatus::AwaitingFunding);\n    assert!(escrow.multisig_address.is_some());\n    \n    // 6. Buyer funds escrow\n    let tx_hash = test_env.fund_escrow(\n        buyer.id,\n        escrow.id,\n        100_000_000,\n    ).await?;\n    \n    // Wait for confirmations (testnet)\n    test_env.wait_for_confirmations(tx_hash, 10).await?;\n    \n    // Verify escrow status\n    let escrow = test_env.get_escrow(escrow.id).await?;\n    assert_eq!(escrow.status, EscrowStatus::Funded);\n    assert_eq!(escrow.balance, 100_000_000);\n    \n    // 7. Vendor marks as shipped\n    test_env.mark_shipped(vendor.id, order.id).await?;\n    \n    // 8. Buyer confirms delivery and releases funds\n    test_env.confirm_delivery(buyer.id, order.id).await?;\n    \n    // 9. Release funds (requires 2-of-3 signatures)\n    test_env.release_funds(escrow.id).await?;\n    \n    // Verify final state\n    let escrow = test_env.get_escrow(escrow.id).await?;\n    assert_eq!(escrow.status, EscrowStatus::Released);\n    \n    let order = test_env.get_order(order.id).await?;\n    assert_eq!(order.status, OrderStatus::Completed);\n    \n    // Verify vendor received payment\n    let vendor_balance = test_env.get_user_balance(vendor.id).await?;\n    assert_eq!(vendor_balance, 100_000_000);\n}\n\n#[tokio::test]\nasync fn test_dispute_resolution() {\n    let test_env = TestEnvironment::setup().await;\n    \n    // Setup (same as above until funded)\n    let (buyer, vendor, arbiter, escrow) = test_env\n        .setup_funded_escrow()\n        .await?;\n    \n    // Buyer opens dispute\n    let dispute = test_env.open_dispute(\n        buyer.id,\n        escrow.id,\n        \"Item not as described\",\n    ).await?;\n    \n    assert_eq!(dispute.status, DisputeStatus::Open);\n    \n    // Arbiter reviews evidence\n    test_env.add_dispute_evidence(\n        buyer.id,\n        dispute.id,\n        vec![/* file uploads */],\n    ).await?;\n    \n    test_env.add_dispute_evidence(\n        vendor.id,\n        dispute.id,\n        vec![/* counter-evidence */],\n    ).await?;\n    \n    // Arbiter makes decision (partial refund)\n    let resolution = test_env.resolve_dispute(\n        arbiter.id,\n        dispute.id,\n        ResolutionType::PartialRefund {\n            buyer_amount: 60_000_000,  // 60% to buyer\n            vendor_amount: 40_000_000, // 40% to vendor\n        },\n        \"Item was damaged, partial refund warranted\",\n    ).await?;\n    \n    // Execute resolution (requires arbiter + one party)\n    test_env.execute_resolution(escrow.id, resolution.id).await?;\n    \n    // Verify final balances\n    let buyer_balance = test_env.get_user_balance(buyer.id).await?;\n    let vendor_balance = test_env.get_user_balance(vendor.id).await?;\n    \n    assert_eq!(buyer_balance, 60_000_000);\n    assert_eq!(vendor_balance, 40_000_000);\n}\n\n#[tokio::test]\nasync fn test_websocket_notifications() {\n    let test_env = TestEnvironment::setup().await;\n    \n    // Connect buyer via WebSocket\n    let mut buyer_ws = test_env.connect_websocket(buyer.id).await?;\n    \n    // Subscribe to escrow events\n    buyer_ws.send(WsMessage::Subscribe {\n        escrow_id: escrow.id,\n    }).await?;\n    \n    // Create escrow in another thread\n    let escrow_id = tokio::spawn(async move {\n        test_env.create_escrow(/* ... */).await\n    });\n    \n    // Wait for notification\n    let notification = timeout(\n        Duration::from_secs(5),\n        buyer_ws.recv()\n    ).await??;\n    \n    match notification {\n        WsEvent::EscrowCreated { escrow_id, .. } => {\n            assert_eq!(escrow_id, escrow_id);\n        }\n        _ => panic!(\"Unexpected notification\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_concurrent_escrow_operations() {\n    let test_env = TestEnvironment::setup().await;\n    \n    // Create 10 concurrent escrows\n    let mut handles = vec![];\n    \n    for i in 0..10 {\n        let test_env = test_env.clone();\n        let handle = tokio::spawn(async move {\n            let buyer = test_env.create_user(&format!(\"buyer{}@test.com\", i)).await?;\n            let vendor = test_env.create_user(&format!(\"vendor{}@test.com\", i)).await?;\n            let arbiter = test_env.get_arbiter().await?;\n            \n            let listing = test_env.create_listing(vendor.id, \"Product\").await?;\n            let order = test_env.create_order(buyer.id, listing.id).await?;\n            let escrow = test_env.initialize_escrow(order.id, arbiter.id).await?;\n            \n            test_env.complete_multisig_setup(escrow.id).await?;\n            Ok::<_, anyhow::Error>(escrow.id)\n        });\n        \n        handles.push(handle);\n    }\n    \n    // Wait for all to complete\n    let results = futures::future::join_all(handles).await;\n    \n    // Verify all succeeded\n    for result in results {\n        assert!(result.is_ok());\n    }\n}\n```\n\n**Test Environment Helper**:\n```rust\npub struct TestEnvironment {\n    db_pool: PgPool,\n    app: TestApp,\n    monero_testnet: MoneroTestnet,\n    ws_server: Addr<WebSocketServer>,\n}\n\nimpl TestEnvironment {\n    pub async fn setup() -> Self {\n        // 1. Start isolated test database\n        let db_url = format!(\n            \"postgres://test:test@localhost/{}_{}\",\n            \"test_db\",\n            Uuid::new_v4()\n        );\n        \n        let db_pool = create_test_database(&db_url).await;\n        run_migrations(&db_pool).await;\n        \n        // 2. Start local Monero testnet (monerod + 3 wallet RPCs)\n        let monero_testnet = MoneroTestnet::start().await;\n        \n        // 3. Initialize application\n        let config = AppConfig {\n            environment: Environment::Development,\n            database_url: db_url,\n            monero_wallet_rpc_urls: monero_testnet.wallet_urls(),\n            // ... test config\n        };\n        \n        let app = TestApp::new(config).await;\n        \n        Self {\n            db_pool,\n            app,\n            monero_testnet,\n            ws_server: app.ws_server.clone(),\n        }\n    }\n    \n    pub async fn teardown(self) {\n        self.monero_testnet.stop().await;\n        drop_test_database(&self.db_pool).await;\n    }\n}\n```\n\n---\n\n#### 3.3 Production Monitoring & Observability\n\n**New File**: `server/src/telemetry/mod.rs`\n\n```rust\nuse opentelemetry::{global, KeyValue};\nuse opentelemetry_otlp::WithExportConfig;\nuse prometheus::{Encoder, Registry, TextEncoder};\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\npub fn init_telemetry(config: &AppConfig) -> anyhow::Result<()> {\n    // 1. Setup tracing\n    let tracer = opentelemetry_otlp::new_pipeline()\n        .tracing()\n        .with_exporter(\n            opentelemetry_otlp::new_exporter()\n                .tonic()\n                .with_endpoint(config.tracing_endpoint.clone().unwrap_or_default())\n        )\n        .with_trace_config(\n            opentelemetry::sdk::trace::config()\n                .with_resource(opentelemetry::sdk::Resource::new(vec![\n                    KeyValue::new(\"service.name\", \"monero-marketplace\"),\n                    KeyValue::new(\"service.version\", config.version.clone()),\n                    KeyValue::new(\"environment\", format!(\"{:?}\", config.environment)),\n                ]))\n        )\n        .install_batch(opentelemetry::runtime::Tokio)?;\n    \n    // 2. Setup logging\n    let log_layer = tracing_subscriber::fmt::layer()\n        .json()\n        .with_target(true)\n        .with_current_span(true);\n    \n    let telemetry_layer = tracing_opentelemetry::layer().with_tracer(tracer);\n    \n    tracing_subscriber::registry()\n        .with(log_layer)\n        .with(telemetry_layer)\n        .with(tracing_subscriber::EnvFilter::new(&config.log_level))\n        .init();\n    \n    Ok(())\n}\n```\n\n**Metrics Definition** (`server/src/telemetry/metrics.rs`):\n\n```rust\nuse prometheus::{\n    register_histogram_vec, register_int_counter_vec, register_int_gauge_vec,\n    HistogramVec, IntCounterVec, IntGaugeVec,\n};\n\nlazy_static! {\n    // Business metrics\n    pub static ref ESCROWS_TOTAL: IntCounterVec = register_int_counter_vec!(\n        \"escrows_total\",\n        \"Total number of escrows created\",\n        &[\"status\"]\n    ).unwrap();\n    \n    pub static ref ESCROWS_ACTIVE: IntGaugeVec = register_int_gauge_vec!(\n        \"escrows_active\",\n        \"Number of active escrows\",\n        &[\"status\"]\n    ).unwrap();\n    \n    pub static ref ESCROW_VOLUME_XMR: HistogramVec = register_histogram_vec!(\n        \"escrow_volume_xmr\",\n        \"Escrow volume in XMR\",\n        &[\"status\"],\n        vec![0.1, 0.5, 1.0, 5.0, 10.0, 50.0]\n    ).unwrap();\n    \n    // Technical metrics\n    pub static ref HTTP_REQUESTS_TOTAL: IntCounterVec = register_int_counter_vec!(\n        \"http_requests_total\",\n        \"Total HTTP requests\",\n        &[\"method\", \"path\", \"status\"]\n    ).unwrap();\n    \n    pub static ref HTTP_REQUEST_DURATION: HistogramVec = register_histogram_vec!(\n        \"http_request_duration_seconds\",\n        \"HTTP request latency\",\n        &[\"method\", \"path\"],\n        vec![0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0]\n    ).unwrap();\n    \n    pub static ref MONERO_RPC_CALLS: IntCounterVec = register_int_counter_vec!(\n        \"monero_rpc_calls_total\",\n        \"Monero RPC calls\",\n        &[\"method\", \"status\"]\n    ).unwrap();\n    \n    pub static ref MONERO_RPC_DURATION: HistogramVec = register_histogram_vec!(\n        \"monero_rpc_duration_seconds\",\n        \"Monero RPC latency\",\n        &[\"method\"],\n        vec![0.1, 0.5, 1.0, 5.0, 10.0]\n    ).unwrap();\n    \n    pub static ref DB_CONNECTIONS: IntGaugeVec = register_int_gauge_vec!(\n        \"db_connections\",\n        \"Database connection pool\",\n        &[\"state\"]\n    ).unwrap();\n    \n    pub static ref WS_CONNECTIONS: IntGaugeVec = register_int_gauge_vec!(\n        \"websocket_connections_active\",\n        \"Active WebSocket connections\",\n        &[]\n    ).unwrap();\n    \n    pub static ref CIRCUIT_BREAKER_STATE: IntGaugeVec = register_int_gauge_vec!(\n        \"circuit_breaker_state\",\n        \"Circuit breaker state (0=closed, 1=open, 2=half-open)\",\n        &[\"service\"]\n    ).unwrap();\n}\n\n// Middleware for automatic HTTP metrics\npub struct MetricsMiddleware;\n\nimpl<S, B> Transform<S, ServiceRequest> for MetricsMiddleware\nwhere\n    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,\n{\n    fn call(&self, req: ServiceRequest) -> Self::Future {\n        let method = req.method().as_str().to_owned();\n        let path = req.path().to_owned();\n        let start = Instant::now();\n        \n        Box::pin(async move {\n            let res = self.service.call(req).await?;\n            \n            let duration = start.elapsed().as_secs_f64();\n            let status = res.status().as_u16().to_string();\n            \n            HTTP_REQUESTS_TOTAL\n                .with_label_values(&[&method, &path, &status])\n                .inc();\n            \n            HTTP_REQUEST_DURATION\n                .with_label_values(&[&method, &path])\n                .observe(duration);\n            \n            Ok(res)\n        })\n    }\n}\n```\n\n**Alerting Rules** (`deployment/prometheus/alerts.yml`):\n\n```yaml\ngroups:\n  - name: monero_marketplace\n    interval: 30s\n    rules:\n      # Service availability\n      - alert: ServiceDown\n        expr: up{job=\"monero-marketplace\"} == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Service {{ $labels.instance }} is down\"\n          \n      # Monero RPC issues\n      - alert: MoneroRpcDown\n        expr: |\n          sum(rate(monero_rpc_calls_total{status=\"error\"}[5m])) \n          / sum(rate(monero_rpc_calls_total[5m])) > 0.5\n        for: 2m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Monero RPC error rate > 50%\"\n          \n      - alert: MoneroRpcSlow\n        expr: |\n          histogram_quantile(0.95, \n            rate(monero_rpc_duration_seconds_bucket[5m])\n          ) > 5\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Monero RPC P95 latency > 5s\"\n          \n      # Business logic\n      - alert: EscrowStuck\n        expr: |\n          max(time() - escrow_last_update_timestamp{status=\"funded\"}) \n          > 1800\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Escrow stuck in funded state for 30+ minutes\"\n          \n      - alert: HighErrorRate\n        expr: |\n          sum(rate(http_requests_total{status=~\"5..\"}[5m])) \n          / sum(rate(http_requests_total[5m])) > 0.05\n        for: 3m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"HTTP error rate > 5%\"\n          \n      # Security\n      - alert: RateLimitExceeded\n        expr: rate(rate_limit_exceeded_total[1m]) > 10\n        for: 2m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High rate of rate limit violations\"\n          \n      - alert: FailedLoginAttempts\n        expr: rate(failed_login_attempts_total[5m]) > 5\n        for: 3m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Elevated failed login attempts\"\n          \n      # Resource usage\n      - alert: DatabaseConnectionPoolExhausted\n        expr: |\n          db_connections{state=\"idle\"} \n          / (db_connections{state=\"idle\"} + db_connections{state=\"active\"}) \n          < 0.1\n        for: 2m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Database connection pool near exhaustion\"\n```\n\n---\n\n### PHASE 4: Production Deployment (Week 4)\n\n#### 4.1 Docker Production Setup\n\n**File**: `deployment/Dockerfile.server`\n\n```dockerfile\n# Build stage\nFROM rust:1.75-slim as builder\n\nWORKDIR /app\n\n# Install dependencies\nRUN apt-get update && apt-get install -y \\\n    libssl-dev \\\n    pkg-config \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy manifests\nCOPY Cargo.toml Cargo.lock ./\nCOPY server/Cargo.toml ./server/\nCOPY wallet/Cargo.toml ./wallet/\nCOPY common/Cargo.toml ./common/\nCOPY cli/Cargo.toml ./cli/\n\n# Build dependencies (cached layer)\nRUN mkdir -p server/src wallet/src common/src cli/src && \\\n    echo \"fn main() {}\" > server/src/main.rs && \\\n    echo \"fn main() {}\" > wallet/src/main.rs && \\\n    echo \"fn main() {}\" > common/src/main.rs && \\\n    echo \"fn main() {}\" > cli/src/main.rs && \\\n    cargo build --release --features mainnet && \\\n    rm -rf server/src wallet/src common/src cli/src\n\n# Copy source\nCOPY . .\n\n# Build application\nRUN cargo build --release --features mainnet --bin server\n\n# Runtime stage\nFROM debian:bookworm-slim\n\nRUN apt-get update && apt-get install -y \\\n    ca-certificates \\\n    libssl3 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Create app user\nRUN useradd -m -u 1000 -s /bin/bash appuser\n\nWORKDIR /app\n\n# Copy binary\nCOPY --from=builder /app/target/release/server /app/server\n\n# Copy migrations\nCOPY server/migrations /app/migrations\n\n# Set ownership\nRUN chown -R appuser:appuser /app\n\nUSER appuser\n\nEXPOSE 8080 9090\n\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:8080/health || exit 1\n\nENTRYPOINT [\"/app/server\"]\n```\n\n**File**: `deployment/docker-compose.production.yml`\n\n```yaml\nversion: '3.8'\n\nservices:\n  # Monero daemon\n  monerod:\n    image: sethsimmons/simple-monerod:latest\n    container_name: monerod\n    restart: unless-stopped\n    volumes:\n      - monero-data:/home/monero/.bitmonero\n    ports:\n      - \"18081:18081\"  # P2P\n      - \"18089:18089\"  # RPC (restricted)\n    command: >\n      --rpc-bind-ip=0.0.0.0\n      --rpc-bind-port=18089\n      --restricted-rpc\n      --confirm-external-bind\n      --no-igd\n      --db-sync-mode=safe\n      --prune-blockchain\n    networks:\n      - monero-net\n      \n  # Wallet RPC instances (3 for multisig)\n  wallet-rpc-1:\n    image: sethsimmons/simple-monero-wallet-rpc:latest\n    container_name: wallet-rpc-1\n    restart: unless-stopped\n    depends_on:\n      - monerod\n    volumes:\n      - wallet-data-1:/home/monero/wallet\n    environment:\n      - DAEMON_HOST=monerod\n      - DAEMON_PORT=18089\n      - RPC_BIND_PORT=18083\n      - RPC_USER=${WALLET_RPC_USER}\n      - RPC_PASSWORD=${WALLET_RPC_PASSWORD}\n    networks:\n      - monero-net\n      \n  wallet-rpc-2:\n    image: sethsimmons/simple-monero-wallet-rpc:latest\n    container_name: wallet-rpc-2\n    restart: unless-stopped\n    depends_on:\n      - monerod\n    volumes:\n      - wallet-data-2:/home/monero/wallet\n    environment:\n      - DAEMON_HOST=monerod\n      - DAEMON_PORT=18089\n      - RPC_BIND_PORT=18083\n      - RPC_USER=${WALLET_RPC_USER}\n      - RPC_PASSWORD=${WALLET_RPC_PASSWORD}\n    networks:\n      - monero-net\n      \n  wallet-rpc-3:\n    image: sethsimmons/simple-monero-wallet-rpc:latest\n    container_name: wallet-rpc-3\n    restart: unless-stopped\n    depends_on:\n      - monerod\n    volumes:\n      - wallet-data-3:/home/monero/wallet\n    environment:\n      - DAEMON_HOST=monerod\n      - DAEMON_PORT=18089\n      - RPC_BIND_PORT=18083\n      - RPC_USER=${WALLET_RPC_USER}\n      - RPC_PASSWORD=${WALLET_RPC_PASSWORD}\n    networks:\n      - monero-net\n \n  # PostgreSQL database\n  postgres:\n    image: postgres:16-alpine\n    container_name: postgres\n    restart: unless-stopped\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n      - ./backups:/backups\n    environment:\n      - POSTGRES_DB=${DB_NAME}\n      - POSTGRES_USER=${DB_USER}\n      - POSTGRES_PASSWORD=${DB_PASSWORD}\n    ports:\n      - \"127.0.0.1:5432:5432\"\n    networks:\n      - monero-net\n    command: >\n      postgres\n      -c max_connections=200\n      -c shared_buffers=256MB\n      -c effective_cache_size=1GB\n      -c maintenance_work_mem=64MB\n      -c checkpoint_completion_target=0.9\n      -c wal_buffers=16MB\n      -c default_statistics_target=100\n      \n  # Application server\n  server:\n    build:\n      context: ..\n      dockerfile: deployment/Dockerfile.server\n    container_name: monero-marketplace-server\n    restart: unless-stopped\n    depends_on:\n      - postgres\n      - wallet-rpc-1\n      - wallet-rpc-2\n      - wallet-rpc-3\n    volumes:\n      - ./encryption-keys:/app/keys:ro\n      - ./logs:/app/logs\n    environment:\n      - APP_ENV=production\n      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/${DB_NAME}\n      - MONERO_WALLET_RPC_URLS=http://wallet-rpc-1:18083,http://wallet-rpc-2:18083,http://wallet-rpc-3:18083\n      - MONERO_DAEMON_URL=http://monerod:18089\n      - ENCRYPTION_KEY_PATH=/app/keys/master.key\n      - SERVER_HOST=0.0.0.0\n      - SERVER_PORT=8080\n      - METRICS_PORT=9090\n      - RUST_LOG=info\n    ports:\n      - \"127.0.0.1:8080:8080\"  # API (behind nginx)\n      - \"127.0.0.1:9090:9090\"  # Metrics\n    networks:\n      - monero-net\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n      \n  # Nginx reverse proxy\n  nginx:\n    image: nginx:alpine\n    container_name: nginx\n    restart: unless-stopped\n    depends_on:\n      - server\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\n      - ./nginx/ssl:/etc/nginx/ssl:ro\n      - nginx-cache:/var/cache/nginx\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    networks:\n      - monero-net\n      \n  # Tor hidden service\n  tor:\n    image: goldy/tor-hidden-service:latest\n    container_name: tor\n    restart: unless-stopped\n    depends_on:\n      - nginx\n    volumes:\n      - tor-keys:/var/lib/tor/hidden_service\n    environment:\n      - HIDDEN_SERVICE_NAME=monero_marketplace\n      - HIDDEN_SERVICE_PORT=80\n      - HIDDEN_SERVICE_TARGET=nginx:80\n    networks:\n      - monero-net\n      \n  # Prometheus monitoring\n  prometheus:\n    image: prom/prometheus:latest\n    container_name: prometheus\n    restart: unless-stopped\n    volumes:\n      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro\n      - ./prometheus/alerts.yml:/etc/prometheus/alerts.yml:ro\n      - prometheus-data:/prometheus\n    command:\n      - '--config.file=/etc/prometheus/prometheus.yml'\n      - '--storage.tsdb.path=/prometheus'\n      - '--storage.tsdb.retention.time=30d'\n    ports:\n      - \"127.0.0.1:9091:9090\"\n    networks:\n      - monero-net\n      \n  # Grafana dashboards\n  grafana:\n    image: grafana/grafana:latest\n    container_name: grafana\n    restart: unless-stopped\n    depends_on:\n      - prometheus\n    volumes:\n      - grafana-data:/var/lib/grafana\n      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards:ro\n      - ./grafana/datasources:/etc/grafana/provisioning/datasources:ro\n    environment:\n      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}\n      - GF_USERS_ALLOW_SIGN_UP=false\n    ports:\n      - \"127.0.0.1:3000:3000\"\n    networks:\n      - monero-net\n\nvolumes:\n  monero-data:\n  wallet-data-1:\n  wallet-data-2:\n  wallet-data-3:\n  postgres-data:\n  nginx-cache:\n  tor-keys:\n  prometheus-data:\n  grafana-data:\n\nnetworks:\n  monero-net:\n    driver: bridge\n```\n\n---\n\n#### 4.2 Deployment Automation\n\n**File**: `scripts/deploy-production.sh`\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nPROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"\nDEPLOYMENT_DIR=\"$PROJECT_ROOT/deployment\"\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nlog_info() { echo -e \"${GREEN}[INFO]${NC} $1\"; }\nlog_warn() { echo -e \"${YELLOW}[WARN]${NC} $1\"; }\nlog_error() { echo -e \"${RED}[ERROR]${NC} $1\"; }\n\n# Preflight checks\npreflight_checks() {\n    log_info \"Running preflight checks...\"\n    \n    # Check environment\n    if [[ \"${APP_ENV:-}\" != \"production\" ]]; then\n        log_error \"APP_ENV must be set to 'production'\"\n        exit 1\n    fi\n    \n    # Check required files\n    if [[ ! -f \"$DEPLOYMENT_DIR/.env.production\" ]]; then\n        log_error \"Missing .env.production file\"\n        exit 1\n    fi\n    \n    # Check encryption key\n    if [[ ! -f \"$DEPLOYMENT_DIR/encryption-keys/master.key\" ]]; then\n        log_error \"Missing encryption key\"\n        exit 1\n    fi\n    \n    # Verify key permissions\n    key_perms=$(stat -c \"%a\" \"$DEPLOYMENT_DIR/encryption-keys/master.key\")\n    if [[ \"$key_perms\" != \"600\" ]]; then\n        log_error \"Encryption key must have 600 permissions\"\n        exit 1\n    fi\n    \n    # Check Git status\n    if [[ -n $(git status --porcelain) ]]; then\n        log_warn \"Working directory not clean\"\n        read -p \"Continue anyway? (y/N) \" -n 1 -r\n        echo\n        if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n            exit 1\n        fi\n    fi\n    \n    # Run security checks\n    log_info \"Running security checks...\"\n    cargo audit || {\n        log_error \"Security vulnerabilities found\"\n        exit 1\n    }\n    \n    # Check for TODOs in production code\n    if grep -r \"TODO\\|FIXME\" server/src --exclude-dir=tests; then\n        log_error \"Found TODO/FIXME in production code\"\n        exit 1\n    fi\n    \n    log_info \"Preflight checks passed âœ“\"\n}\n\n# Backup database\nbackup_database() {\n    log_info \"Creating database backup...\"\n    \n    local backup_file=\"backup_$(date +%Y%m%d_%H%M%S).sql\"\n    \n    docker exec postgres pg_dump \\\n        -U \"${DB_USER}\" \\\n        -d \"${DB_NAME}\" \\\n        > \"$DEPLOYMENT_DIR/backups/$backup_file\"\n    \n    gzip \"$DEPLOYMENT_DIR/backups/$backup_file\"\n    \n    log_info \"Backup created: $backup_file.gz\"\n}\n\n# Build and deploy\ndeploy() {\n    log_info \"Starting deployment...\"\n    \n    cd \"$DEPLOYMENT_DIR\"\n    \n    # Pull latest code\n    git pull origin main\n    \n    # Build images\n    log_info \"Building Docker images...\"\n    docker-compose -f docker-compose.production.yml build --no-cache server\n    \n    # Run database migrations\n    log_info \"Running database migrations...\"\n    docker-compose -f docker-compose.production.yml run --rm server \\\n        diesel migration run\n    \n    # Deploy with zero downtime\n    log_info \"Deploying new version...\"\n    docker-compose -f docker-compose.production.yml up -d --no-deps --force-recreate server\n    \n    # Wait for health check\n    log_info \"Waiting for health check...\"\n    sleep 10\n    \n    for i in {1..30}; do\n        if curl -f http://localhost:8080/health > /dev/null 2>&1; then\n            log_info \"Health check passed âœ“\"\n            break\n        fi\n        \n        if [[ $i -eq 30 ]]; then\n            log_error \"Health check failed after 30 attempts\"\n            rollback\n            exit 1\n        fi\n        \n        sleep 2\n    done\n    \n    log_info \"Deployment successful âœ“\"\n}\n\n# Rollback procedure\nrollback() {\n    log_warn \"Initiating rollback...\"\n    \n    cd \"$DEPLOYMENT_DIR\"\n    \n    # Revert to previous version\n    docker-compose -f docker-compose.production.yml up -d --no-deps --force-recreate server\n    \n    log_info \"Rollback completed\"\n}\n\n# Post-deployment checks\npost_deployment_checks() {\n    log_info \"Running post-deployment checks...\"\n    \n    # Check all services are running\n    if ! docker-compose -f \"$DEPLOYMENT_DIR/docker-compose.production.yml\" ps | grep -q \"Up\"; then\n        log_error \"Not all services are running\"\n        return 1\n    fi\n    \n    # Check metrics endpoint\n    if ! curl -f http://localhost:9090/metrics > /dev/null 2>&1; then\n        log_warn \"Metrics endpoint not responding\"\n    fi\n    \n    # Check WebSocket\n    if ! wscat -c ws://localhost:8080/ws --execute \"ping\" > /dev/null 2>&1; then\n        log_warn \"WebSocket not responding\"\n    fi\n    \n    # Check Monero RPC\n    local rpc_count=$(docker-compose ps | grep wallet-rpc | grep \"Up\" | wc -l)\n    if [[ $rpc_count -ne 3 ]]; then\n        log_error \"Not all wallet RPC instances are running\"\n        return 1\n    fi\n    \n    log_info \"Post-deployment checks passed âœ“\"\n}\n\n# Cleanup old versions\ncleanup() {\n    log_info \"Cleaning up old Docker images...\"\n    docker image prune -f\n    \n    # Keep last 5 backups\n    cd \"$DEPLOYMENT_DIR/backups\"\n    ls -t backup_*.sql.gz | tail -n +6 | xargs -r rm\n    \n    log_info \"Cleanup completed âœ“\"\n}\n\n# Main execution\nmain() {\n    log_info \"=== Monero Marketplace Production Deployment ===\"\n    log_info \"Started at: $(date)\"\n    \n    # Load environment\n    source \"$DEPLOYMENT_DIR/.env.production\"\n    \n    # Execute deployment steps\n    preflight_checks\n    backup_database\n    deploy\n    post_deployment_checks\n    cleanup\n    \n    log_info \"=== Deployment Complete ===\"\n    log_info \"Finished at: $(date)\"\n    \n    # Display summary\n    echo \"\"\n    log_info \"Services:\"\n    docker-compose -f \"$DEPLOYMENT_DIR/docker-compose.production.yml\" ps\n    \n    echo \"\"\n    log_info \"Next steps:\"\n    echo \"  1. Monitor logs: docker-compose logs -f server\"\n    echo \"  2. Check metrics: http://localhost:9091\"\n    echo \"  3. View dashboards: http://localhost:3000\"\n}\n\n# Trap errors\ntrap 'log_error \"Deployment failed at line $LINENO\"' ERR\n\n# Run\nmain \"$@\"\n```\n\n**File**: `scripts/health-check-production.sh`\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Health check script for monitoring\n\ncheck_service() {\n    local service=$1\n    local url=$2\n    \n    if curl -f -s --max-time 5 \"$url\" > /dev/null; then\n        echo \"âœ“ $service: healthy\"\n        return 0\n    else\n        echo \"âœ— $service: unhealthy\"\n        return 1\n    fi\n}\n\ncheck_monero_rpc() {\n    local rpc_url=$1\n    local response=$(curl -s --max-time 5 -X POST \"$rpc_url/json_rpc\" \\\n        -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_version\"}' \\\n        -H 'Content-Type: application/json')\n    \n    if echo \"$response\" | grep -q \"result\"; then\n        echo \"âœ“ Monero RPC: healthy\"\n        return 0\n    else\n        echo \"âœ— Monero RPC: unhealthy\"\n        return 1\n    fi\n}\n\nmain() {\n    echo \"=== Health Check ===\"\n    echo \"Time: $(date)\"\n    echo \"\"\n    \n    local exit_code=0\n    \n    # Check application\n    check_service \"API Server\" \"http://localhost:8080/health\" || exit_code=1\n    check_service \"Metrics\" \"http://localhost:9090/metrics\" || exit_code=1\n    \n    # Check Monero services\n    check_monero_rpc \"http://localhost:18083\" || exit_code=1\n    \n    # Check database\n    if docker exec postgres pg_isready -U \"$DB_USER\" > /dev/null 2>&1; then\n        echo \"âœ“ PostgreSQL: healthy\"\n    else\n        echo \"âœ— PostgreSQL: unhealthy\"\n        exit_code=1\n    fi\n    \n    # Check disk space\n    local disk_usage=$(df -h / | tail -1 | awk '{print $5}' | sed 's/%//')\n    if [[ $disk_usage -gt 80 ]]; then\n        echo \"âš  Disk usage: ${disk_usage}% (warning)\"\n        exit_code=1\n    else\n        echo \"âœ“ Disk usage: ${disk_usage}%\"\n    fi\n    \n    echo \"\"\n    if [[ $exit_code -eq 0 ]]; then\n        echo \"=== All checks passed ===\"\n    else\n        echo \"=== Some checks failed ===\"\n    fi\n    \n    return $exit_code\n}\n\nmain"
    },
    "prompt": "Analyse ce plan de dÃ©ploiement et identifie les risques."
}